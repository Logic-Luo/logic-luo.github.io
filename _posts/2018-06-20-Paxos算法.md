---
layout:     post
title:      Paxos算法
subtitle:   
date:       2018-06-20
author:     Logic
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - zookeeper
    - paxos
---
### 问题描述

假设有一组可以提出提案的进程集合，那么对于一个一致性算法来说需要保证以下几点：
- 在这些被提出的提案中，只有一个会被选定。
- 如果没有提案被提出，那么不会有被选定的提案。
- 当一个提案被选定后，进程应该可以获取被选定的提案信息。

对于一致性来说，安全性需要满足如下：
- 只有被提出的提案才能被选定。
- 只能有一个值被选定。
- 如果某个进程认为某个提案被选定了，那么这个提案必须是真的被选定的那个。

在对Paxos算法的讲解过程中，我们不去精确地定义其活性(Liveness)需求，从整体上来说Pasox算法的目标就是要保证最终有一个提案被选定，当提案被选定后，进程最终也能获取到选定的提案。

在该一致性算法中，有三种参与角色，我们用Proposer(提案的提出者)、Acceptor(提案决定这)和Learner(获取最终的提案结果)来表示。在具体的实现中，一个进程可能充当不止一种角色，在这里我们并不关心进程如何映射到各种角色。假设不同参与者之间可以通过收发消息来进行通信，那么：
- 每个参与者以任意速度执行，可能会因为出错而停止，可能会重启。同时即使一个提案被选定后，所有参与者也都有可能失败或重启，因此除非那些失败或重启的参与者可以记录某些信息，否则将无法确定最终的值。
- 消息在传输过程中可能会出现不可预知的延迟，也可能会重复或丢失，但是消息不会被破坏，即消息内容不会被篡改。

### 提案的选定
要选定一个唯一提案最简单的方式莫过于只允许一个Acceptor存在，这样的话，Proposer 只能发送提案给该Acceptor，Acceptor 会选择它接收到的第一个提案作为选定的提案